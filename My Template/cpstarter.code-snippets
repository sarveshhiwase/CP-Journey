{
	// Place your global snippets here. Each snippet is defined under a snippet name and has a scope, prefix, body and 
	// description. Add comma separated ids of the languages where the snippet is applicable in the scope field. If scope 
	// is left empty or omitted, the snippet gets applied to all languages. The prefix is what is 
	// used to trigger the snippet and the body will be expanded and inserted. Possible variables are: 
	// $1, $2 for tab stops, $0 for the final cursor position, and ${1:label}, ${2:another} for placeholders. 
	// Placeholders with the same ids are connected.
	// Example:
	// "Print to console": {
	// 	"scope": "javascript,typescript",
	// 	"prefix": "log",
	// 	"body": [
	// 		"console.log('$1');",
	// 		"$2"
	// 	],
	// 	"description": "Log output to console"
	// }
	"Competitive Template": {
		"prefix": "cpstarter",
		"body": [
		  "#include <bits/stdc++.h>",
		  "using namespace std;",
		  "",
		  "// Macros",
		  "#define F first",
		  "#define S second",
		  "#define all(x) begin(x), end(x)",
		  "#define allr(x) rbegin(x), rend(x)",
		  "#define int long long int",
		  "#define print_same(x) cout << x << \" \";",
		  "",
		  "// Aliases",
		  "using ull = unsigned int;",
		  "using ld = long double;",
		  "",
		  "// Constants",
		  "constexpr int INF = 2e18;",
		  "constexpr ld EPS = 1e-9;",
		  "constexpr int MOD = 1e9 + 7;",
		  "",
		  "// Operator overloads",
		  "template<typename T1, typename T2> // cin >> pair<T1, T2>",
		  "istream& operator>>(istream &istream, pair<T1, T2> &p) { return (istream >> p.first >> p.second); }",
		  "",
		  "template<typename T> // cin >> vector<T>",
		  "istream& operator>>(istream &istream, vector<T> &v){",
		  "\tfor (auto &it : v)",
		  "\t\tcin >> it;",
		  "\treturn istream;",
		  "}",
		  "",
		  "template<typename T1, typename T2> // cout << pair<T1, T2>",
		  "ostream& operator<<(ostream &ostream, const pair<T1, T2> &p) { return (ostream << p.first << \" \" << p.second); }",
		  "template<typename T> // cout << vector<T>",
		  "ostream& operator<<(ostream &ostream, const vector<T> &c) { for (auto &it : c) cout << it << \" \"; return ostream; }",
		  "",
		  "// Utility functions",
		  "template <typename T>",
		  "void print(T &&t) { cout << t << \"\\n\"; }",
		  "template <typename T, typename... Args>",
		  "void print(T &&t, Args &&... args){",
		  "\tcout << t << \" \";",
		  "\tprint(forward<Args>(args)...);",
		  "}",
		  "",
		  "template <typename T>",
		  "int32_t size_i(T &container) { return static_cast<int32_t>(container.size()); }",
		  "",
		  "// Mathematical functions",
		  "int GCD(int a, int b){",
		  "\twhile (b)",
		  "\t{",
		  "\ta %= b;",
		  "\t\tswap(a, b);",
		  "\t}",
		  "\treturn a;",
		  "}",
		  "",
		  "int GCD_extended(int a, int b, int &x, int &y){",
		  "\tx = 1, y = 0;",
		  "\tint x1 = 0, y1 = 1, a1 = a, b1 = b;",
		  "\twhile (b1){",
		  "\tint q = a1 / b1;",
		  "\ttie(x, x1) = make_tuple(x1, x - q * x1);",
		  "\ttie(y, y1) = make_tuple(y1, y - q * y1);",
		  "\ttie(a1, b1) = make_tuple(b1, a1 - q * b1);",
		  "\t}",
		  "\treturn a1;",
		  "}",
		  "int LCM(int a, int b){",
		  "\treturn ((int)a * b) / GCD(a, b);",
		  "}",
		  "",
		  "int modpow(int x, int n, int m = MOD){",
		  "\tif (x == 0 && n == 0) return 0; // undefined case",
		  "\tint res = 1;",
		  "\twhile (n > 0) ",
		  "\t{",
		  "\t\tif (n % 2)",
		  "\t\t\tres = (res * x) % m;",
		  "\t\tx = (x * x) % m;",
		  "\t\tn /= 2;",
		  "\t}",
		  "\treturn res;",
		  "}",
		  "",
		  "int modinv(int x, int m = MOD){",
		  "\treturn modpow(x, m - 2, m);",
		  "}",
		  "",
		  "",
		  "void solve(int tc){",
		  " ",
		  "}",
		  "",
		  "int32_t main(){",
		  "\tios_base::sync_with_stdio(false);",
		  "\tcin.tie(0);",
		  "\tcout << setprecision(12) << fixed;",
		  "",
		  "\tint tests = 1;",
		  "\t${1:cin>>tests;}",
		  "\tfor (int tt = 1; tt <= tests; tt++)",
		  "\t\tsolve(tt);",
		  "\treturn 0;",
		  "}"
		],
		"description": "Competitive Template"
	  },
	  "inputarray": {
		"prefix": "inputarray",
		"body": [
		  "$1 n;",
		  "cin >> n;",
		  "$1 arr[n];",
		  "for(int i = 0; i < n; i++){",
		  "\tcin >> arr[i];",
		  "}"
		],
		"description": "inputarray"
	  },
	  "sieve of eratosthenes": {
  "prefix": "seive",
  "body": [
    "vector<bool> primes($1${1:1e7+5},1);",
    "",
    "void seive(){",
    "\tprimes[0] = primes[1] = 0;",
    "\tfor(int i = 2; i * i <= $1${1:1e7+5}; i++){",
    "\t\tif(primes[i])",
    "\t\t\tfor(int j = i * i; j <= 1e7+4; j += i){",
    "\t\t\t\tprimes[j] = 0;",
    "\t\t\t}",
    "    }",
    "}"
  ],
  "description": "sieve of eratosthenes"
}

}